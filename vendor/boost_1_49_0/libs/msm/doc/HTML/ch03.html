<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;Tutorial</title><link rel="stylesheet" href="boostbook.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="Meta State Machine (MSM)"><link rel="up" href="pt01.html" title="Part&nbsp;I.&nbsp;User' guide"><link rel="prev" href="ch02s03.html" title="State machine glossary"><link rel="next" href="ch03s02.html" title="Basic front-end"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;3.&nbsp;Tutorial</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s03.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;I.&nbsp;User' guide</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch03s02.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Tutorial"><div class="titlepage"><div><div><h2 class="title"><a name="d0e312"></a>Chapter&nbsp;3.&nbsp;Tutorial</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="ch03.html#d0e315">Design</a></span></dt><dt><span class="sect1"><a href="ch03s02.html">Basic front-end</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch03s02.html#d0e334">A simple example</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e348">Transition table</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e396">Defining states with entry/exit actions</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e409">What do you actually do inside actions / guards?</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e461">Defining a simple state machine</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e519">Defining a submachine</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e554">Orthogonal regions, terminate state, event deferring</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e645">History</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e690">Completion (anonymous) transitions</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e717">Internal transitions</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e819">more row types</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e852">Explicit entry / entry and exit pseudo-state / fork</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e1041">Flags</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e1095">Event Hierarchy</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e1116">Customizing a state machine / Getting more speed</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e1165">Choosing the initial event</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#d0e1178"> Containing state machine (deprecated)</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch03s03.html">Functor front-end</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch03s03.html#d0e1217"> Transition table </a></span></dt><dt><span class="sect2"><a href="ch03s03.html#d0e1250">Defining states with entry/exit actions</a></span></dt><dt><span class="sect2"><a href="ch03s03.html#d0e1269">What do you actually do inside actions / guards (Part 2)?</a></span></dt><dt><span class="sect2"><a href="ch03s03.html#d0e1281">Defining a simple state machine</a></span></dt><dt><span class="sect2"><a href="ch03s03.html#d0e1289">Anonymous transitions</a></span></dt><dt><span class="sect2"><a href="ch03s03.html#d0e1315">Internal
                        transitions</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch03s04.html">eUML (experimental)</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch03s04.html#d0e1394">Transition table</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e1435">A simple example: rewriting only our transition table</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e1466">Defining events, actions and states with entry/exit actions</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e1579">Wrapping up a simple state machine and first complete examples</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e1627">Defining a submachine</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e1643">
                        Attributes / Function call</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e1743">Orthogonal regions, flags, event deferring</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e1855">
                        Customizing a state machine / Getting
                        more speed</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e1890">Completion / Anonymous transitions</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e1908">Internal transitions</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e1939">Other state types</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e2003">Helper functions</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e2106">Phoenix-like STL support</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#d0e2159">Writing actions with Boost.Phoenix (in development)</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch03s05.html">Back-end</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch03s05.html#d0e2218">Creation </a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2227">Starting and stopping a state
                        machine</a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2246">Event dispatching</a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2255">Active state(s)</a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2269">Serialization</a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2322">Base state type </a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2348">Visitor</a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2391">Flags</a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2404">Getting a state</a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2417"> State machine constructor with arguments </a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2457">Trading run-time speed for
                        better compile-time / multi-TU compilation</a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2539">Compile-time state machine analysis </a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2583"> Enqueueing events for later
                        processing </a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2603"> Customizing the message queues </a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2618">Policy definition with Boost.Parameter </a></span></dt><dt><span class="sect2"><a href="ch03s05.html#d0e2626">Choosing when to switch active
                        states </a></span></dt></dl></dd></dl></div><div class="sect1" title="Design"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e315"></a>Design</h2></div></div></div><p>MSM is divided between front&#8211;ends and back-ends. At the moment, there is just
                    one back-end. On the front-end side, you will find three of them which are as
                    many state machine description languages, with many more possible. For potential
                    language writers, this document contains a <a class="link" href="ch06s02.html#internals-front-back-interface">description of the interface
                        between front-end and back-end</a>.</p><p>The first front-end is an adaptation of the example provided in the <a class="link" href="http://boostpro.com/mplbook" target="_top">MPL book</a> with actions
                    defined as pointers to state or state machine methods. The second one is based
                    on functors. The third, eUML (embedded UML) is an experimental language based on
                    Boost.Proto and Boost.Typeof and hiding most of the metaprogramming to increase
                    readability. Both eUML and the functor front-end also offer a functional library
                    (a bit like Boost.Phoenix) for use as action language (UML defining
                    none).</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s03.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="pt01.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch03s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">State machine glossary&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Basic front-end</td></tr></table></div></body></html>